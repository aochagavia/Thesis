\chapter{Analysis results}
\label{sec:analysis-results}

% Q: In which cases does normalization not work as expected?

% FIXME: intro

From a high-level perspective, we observed mainly three categories of issues that cause problems to normalization. We noticed that many students struggled with the concept of preconditions, we identified several relevant programming style issues in student programs and we found limitations in Ask-Elle's normalization procedure. In all three cases, we observed a clear negative effect on Ask-Elle's ability to unify programs.

\section{Confusion around preconditions}

Throughout the assignment, some functions are provided of preconditions to simplify their implementation. For instance, knowing that a list will never be empty means that the student no longer has to write additional code to handle that case.

Contrary to the expectations, preconditions caused confusion among the students, instead of leading to simpler code. Below we consider the case of Exercise 3 to illustrate the problem.

\subsection{Simplicity}

In the assignment document, Exercise 3 specifies that the function \haskell{printField :: Int -> String -> String} should satisfy the property $\forall n\ s.\ n \geq length\ s \Rightarrow length\ (printField\ n\ s) \equiv n$. Here, the left side of the implication is the precondition of the function. Therefore, a good solution is expected to assume that $n \geq length\ s$, without checking whether it holds, as illustrated by Figure \ref{sec:discussion-preconditions-model}.

\begin{figure}[H]
\centering
\begin{minted}{haskell}
printField n s
    | all isDigit s = padding ++ s
    | otherwise = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Exercise 3: Model solution}
\label{sec:discussion-preconditions-model}
\end{figure}

Notice that, while there is no explicit checking for the precondition, the function implicitly specifies what should happen in case the precondition does not hold. If $n < length\ s$, then $n - length\ s < 0$, then \haskell{replicate (n - length s) ' ' = []}. Therefore, this particular implementation of \haskell{printField} will return the original value of \haskell{s} whenever the precondition does not hold.

\subsection{Confusion}

Many students added explicit checks to handle the case in which the precondition does not hold. Since the assignment does not specify what the function should return in such a case, students were allowed to write anything that seemed sensible to them.

\subsubsection{Precondition checking with differing semantics}

Figure \ref{fig:analysis-precondition-example} shows a submission to Exercise 3 where the student adds a guard checking for $n < length\ s$. On the right-hand side of the guard, we observe that the student truncates the string.

Comparing this implementation to the model solution in Figure \ref{sec:discussion-preconditions-model}, we can see that the semantics have changed. The model solution returns \haskell{s} when the precondition does not hold, while this implementation returns \haskell{take n s}.

This is a case in which checking for the precondition leads to a program with different semantics when compared to the model solution. In the context of Ask-Elle, this means that normalizing both programs  results in different normal forms.

\begin{figure}
\centering
\begin{minted}{haskell}
printField n s
    | n < length s  = take n s
    | all isDigit s = padding ++ s
    | otherwise     = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Exercise 3: Explicit precondition with differing semantics}
\label{fig:analysis-precondition-example}
\end{figure}

\subsubsection{Precondition checking with similar semantics}

In some cases, checking for the precondition did not result in different semantics relative to the model solution. Figure \ref{fig:analysis-precondition-similar-semantics} shows a function that explicitly checks for the precondition and returns \haskell{s} when the precondition does not hold.

Even though the semantics of the program are similar to those of the model solution, normalizing both will yield different normal forms. Below we explore a possible way of dealing with this issue.

\begin{figure}
\centering
\begin{minted}{haskell}
printField n s
    | n < length s  = s
    | all isDigit s = padding ++ s
    | otherwise     = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Exercise 3: Explicit precondition with similar semantics}
\label{fig:analysis-precondition-similar-semantics}
\end{figure}

\subsection{Normalization up to preconditions}

Program slicing

Remove unreachable branches!

Problem... How do we know they are unreachable?

Section \ref{sec:discussion-preconditions} considers a possible way to deal with this issue in the future, through a normalization mechanism that takes preconditions into account.

% Note: we could talk about implicit preconditions in other exercises that call this function. Very clear in 7 and 8, which only accept well formed tables (though I am not sure that requirement is derived from this precondition).

\section{Style issues}

We identified problems related to four domains: lists, booleans, the \haskell{Maybe} type and pattern matching. They are described below.

\subsection{Lists}

The assignment expects students to manipulate lists by combining list-specific functions. We observed two ways this can go wrong.

\subsubsection{Explicit recursion}

Many students fail to use higher-order functions in their implementation. When this happens, they resort to recursive functions, occasionally reimplementing a higher-order function without realizing. For instance, we identified reimplementations of \haskell{map}, \haskell{filter} and \haskell{zip}.

To a lesser extent, we also observed that some students had trouble using pattern matching when defining recursive functions. Instead of pattern matching, some of them used guards to check whether the list was empty. This was then combined with functions such as \haskell{head} and \haskell{tail}. We even found one case of a student that used guards \emph{and} pattern matching in the same function.

% FIXME: add examples

\subsubsection{Suboptimal function usage}

The list below shows an overview of the issues we found:

\begin{itemize}
    \item Using list indexing to manipulate lists, instead of higher-order functions;
    \item Using \haskell{head}, \haskell{!! 0} and \haskell{tail} instead of pattern matching;
    \item Using append (\haskell{++}) when cons (\haskell{:}) would have been sufficient;
    \item Using \haskell{concatMap} when \haskell{map} would have been sufficient;
    \item Using \haskell{mapMaybe} when \haskell{map} would have been sufficient;
    \item Using \haskell{concat (replicate x [e])} instead of \haskell{replicate x e};
    \item Using \haskell{map} multiple times, instead of merging them into one (map fusion);
    \item Applying \haskell{map} only after pattern matching on the list, to ensure it is not empty (as if \haskell{map} were unable to handle the empty list);
    \item Applying \haskell{foldr} to the empty list;
    \item Using \haskell{foldr} when simpler alternatives exist; % unsolved
    \item Reimplementing functions (e.g. \haskell{foldr (++) []} instead of \haskell{concat}). % Note: this can get VERY creative... With filter, zip, map, intercalate, etc.
\end{itemize}

\subsection{Booleans}

Some functions required by the assignment involve dealing with boolean values. We also found a series of issues on this domain:

\begin{itemize}
    \item Reimplementing functions: \haskell{and}, \haskell{all}, \haskell{not};
    \item Checking whether a boolean value is equal to true instead of using it directly (i.e. \haskell{x == True} instead of \haskell{x});
    \item Unnecessary if statement (i.e. \haskell{if cond then True else False} instead of \haskell{cond});
    \item Nested if statements that check for the same condition.
\end{itemize}

\subsection{Maybe}

Exercises 7 and 8 rely on the \haskell{Maybe} type to handle edge cases. Students are expected to use functions from the standard library to manipulate \haskell{Maybe} values, but many of them reimplemented them without realizing. We observed reimplementations of \haskell{fromMaybe}, \haskell{fromJust}, \haskell{isJust}, \haskell{isNothing} and \haskell{fmap}.

Another style problem consists of using a combination of \haskell{isJust} and \haskell{fromJust}, instead of pattern matching, to extract the value from a \haskell{Maybe}. We also observed a disguised version of this pattern, where students use \haskell{fromMaybe} with a magic default value, which is later checked by an if statement. In case the output of \haskell{fromMaybe} turns out to be the magic value, then the original \haskell{Maybe} object was \haskell{Nothing}. Otherwise, it was \haskell{Just}. The code below illustrates the pattern:

\begin{minted}{haskell}
let x = fromMaybe (-1) maybeX
in if x == (-1) then e else f x
\end{minted}

% Note: looks like maybe is an area where advanced analysis would yield interesting results (non-syntactic)... We only dealt with function reimplementation...

\subsection{Patterns}

On the domain of pattern matching, we observed that some students deconstructed and reconstructed tuples instead of using the original tuple directly. This resulted in code like \haskell{let (a, b) = x in f (a, b)}, when \haskell{f x} would have been sufficient.

Besides the aforementioned style issue, some students resorted to nested pattern matching in cases where it was unnecessary. The table below shows an example of this, where the program to the left uses nested pattern matching and the one to the right does not.

\begin{center}
\begin{tabular}{ m{17em} | m{13em} }
    \begin{minted}{haskell}
    case a of
        [] -> []
        xs -> let (x : _) = xs
              in e
    \end{minted}
    &
    \begin{minted}{haskell}
    case a of
        [] -> []
        x : xs -> e
    \end{minted}
\end{tabular}
\end{center}

\section{Normalization issues}

Besides style issues, the student programs uncovered limitations in Ask-Elle's normalization procedure. These issues manifest in the form of unification failures.

The table below shows a group of general unification problems. Each row represents two programs that Ask-Elle fails to unify, even though they have the same semantics:

\begin{center}
\begin{tabular}{ m{13em} | m{13em} }
Any program & Same program, but with dead auxiliary functions added \\
\hline
Any program & Same program, but with some code refactored to call auxiliary functions \\
\hline
Any program & Same program, but with some code refactored to call standard library functions \\
\hline
Any program that calls a commutative function F & Same program, passing the arguments to F in a different order
\end{tabular}
\end{center}

Besides the issues mentioned above, we observed that some lambda expressions fail to unify with their eta reduced version.

% Not really necessary to include this...
% Besides the issues mentioned above, we observed that some programs failed to unify because they followed differing approaches when tackling the problem at hand. Different approaches to a problem that cannot be condensed into a simple case (see concatMap vs concatMap2 in Ex2 and 6323367 in Ex7)

Additional to previous problems, we also discovered domain-specific ones. Interestingly, the domains overlap with the ones we identified when analyzing style issues, except for \haskell{Maybe}. We describe them below.

\subsection{Lists}

The domain of lists shows the highest amount of unification problems. This is not surprising, as most of the code in the assignment manipulates lists. The table below shows pairs of programs that should unify but do not:

\begin{center}
\begin{tabular}{ m{13em} | m{13em} }
String literal & Same literal written as a list of characters \\
\hline
List literal & Same literal written using cons \\
\hline
List comprehension & Same list expressed in terms of higher-order functions \\
\hline
\haskell{xs} & \haskell{xs ++ []} or \haskell{[] ++ xs} \\
\hline
\haskell{[x] ++ xs} & \haskell{x : xs} \\
\hline
\haskell{(x : xs) ++ ys} & \haskell{x : (xs ++ ys)} \\
\hline
\haskell{(xs ++ ys) ++ zs} & \haskell{xs ++ (ys ++ zs)} \\
\hline
\haskell{map f (x : xs)} & \haskell{f x : map f xs} \\
\hline
\haskell{map f . map g} & \haskell{map (f . g)} \\
\hline
\haskell{concatMap f . map g} & \haskell{concatMap (f . g)} \\
\hline
\haskell{concat (x : xs)} & \haskell{x ++ concat xs} \\
\hline
\haskell{concat []} & \haskell{[]} \\
\hline
\haskell{transpose . map (map f)} & \haskell{map (map f) . transpose}
\end{tabular}
\end{center}

Besides the program pairs mentioned above, two semantically equivalent programs do not unify if one is defined in terms of \haskell{foldr} and the other in terms of \haskell{foldl}. The same applies to two programs where one uses \haskell{foldr} and the other uses \haskell{foldr} in combination with \haskell{map}. This is illustrated by the table below:

\begin{center}
\begin{tabular}{ m{12em} | m{16em} }
\haskell{foldr (+) 0} & \haskell{foldl (+) 0} \\
\hline
\haskell{foldr (+) 0 . map (* 2)} & \haskell{foldr (\x acc -> 2 * x + acc) 0}
\end{tabular}
\end{center}

\subsection{Booleans}

In contrast to lists, we observed less issues in the domain of booleans. The table below shows pairs of programs that we expect to unify but do not:

\begin{center}
\begin{tabular}{ m{13em} | m{13em} }
\haskell{if e then x else y} & \haskell{if not e then y else x} \\
\hline
Function using total guards & Same function using a top-level if statement \\
\hline
\haskell{not . elem} & \haskell{notElem} \\
\hline
\haskell{not . isJust} & \haskell{isNothing}
\end{tabular}
\end{center}

% Exercise 3: complexity of unifying arbitrary boolean expressions... A style matter to avoid unnecessary checks, a normalization matter to unify existing checks.

\subsection{Patterns}

The \haskell{case ... of} construct is widely used by students and by Ask-Elle itself in the normalization procedure. Given its flexibility, it is easy to write case expressions that differ syntactically but have similar semantics. A particular case that fails to unify arises when matching on tuples, as shown below:

\begin{center}
\begin{tabular}{ m{15em} | m{14em} }
    \begin{minted}{haskell}
    case (a, b, c) of
        ([], _, _) -> []
        (x : xs, y, z) -> e
    \end{minted}
    &
    \begin{minted}{haskell}
    let y = b
        z = c
    in case a of
        [] -> []
        x : xs -> e
    \end{minted}
\end{tabular}
\end{center}

Since \haskell{b} and \haskell{c} are not being matched against a pattern, the programmer can choose to bind them inside the \haskell{case} or do so inside a \haskell{let}. In both cases, the meaning of the program is the same, but Ask-Elle is unable to unify them.

% do we need to say something about laziness?

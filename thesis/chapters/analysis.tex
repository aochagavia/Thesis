\chapter{Analysis and new transformations}
\label{sec:analysis-results}

We observe multiple issues that cause problems to normalization. First of all, many students struggle with the concept of preconditions. Additionally, we identify several domain-specific issues involving lists, booleans, the \haskell{Maybe} type and patterns. When possible, we add new transformations to alleviate those issues.

\section{Preconditions}
\label{sec:analysis-preconditions}

Throughout the assignment, some functions are provided of preconditions to simplify their implementation. For instance, knowing that a list will never be empty means that the student no longer has to write additional code to handle that case. Contrary to the expectations, preconditions caused confusion among students, instead of leading to simpler code.

\subsection{Explicit and implicit preconditions}

In the assignment document, Exercise 3 specifies that the function \haskell{printField :: Int -> String -> String} should satisfy the property $\forall n\ s.\ n \geq length\ s \Rightarrow length\ (printField\ n\ s) \equiv n$. Here, the left side of the implication is the precondition of the function. Therefore, a good solution is expected to assume that $n \geq length\ s$, without checking whether it holds, as illustrated by Figure \ref{fig:ex3-model-solution}.

\begin{figure}[H]
\centering
\begin{minted}{haskell}
printField n s
    | all isDigit s = padding ++ s
    | otherwise = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Exercise 3 - Model solution}
\label{fig:ex3-model-solution}
\end{figure}

Besides Exercise 3, no other exercise in the assignment mentions properties or preconditions explicitly. However, it is possible to deduce many preconditions from the context. Table \ref{tb:preconditions-implicit} presents a summary.

\begin{table}
\centering
\begin{tabular}{ m{5em} | m{20em} }
Exercise & Precondition \\
\hline
1 & The first argument is a non-empty list \\
\hline
2 & The first argument is a non-empty list \\
\hline
4 & The first argument is a non-empty list \\
\hline
5 & The first argument is a well-formed table \\
\hline
6 & The first argument is a well-formed table \\
\hline
7 & The third argument is a well-formed table \\
\hline
8 & The second argument is a well-formed table
\end{tabular}
\caption{Implicit preconditions}
\label{tb:preconditions-implicit}
\end{table}

\subsection{Preconditions and semantics}
\label{sec:preconditions-and-semantics}

Preconditions allow functions with different semantics to be considered correct. In case the precondition does not hold, the program is allowed to do anything. Therefore, it is possible to have two programs that behave in the same way when the precondition holds, but do different things when it does not hold.

Notice that writing a submission to an exercise always involves specifying what to do when the precondition does not hold, even when there is no explicit checking for the precondition. Consider the solution to Exercise 3 that we present in Figure \ref{fig:ex3-model-solution}. If \haskell{n < length s}, then \haskell{n - length s < 0}, then \haskell{replicate (n - length s) ' ' = []}. Therefore, this particular implementation of \haskell{printField} will return \haskell{s} whenever the precondition does not hold.

% The relationship between preconditions and semantics has implications...

\subsection{Precondition checking}

Many students add explicit checks to handle the case in which the precondition does not hold. Since the assignment does not specify what the function should return in such a case, students are allowed to write anything that seems sensible to them.

\subsubsection{Differing semantics}

Figure \ref{fig:analysis-precondition-example} shows a submission to Exercise 3 where the student adds a guard checking for \haskell{n < length s}. On the right-hand side of the guard, we observe that the student truncates the string.

Comparing this implementation to the model solution in Figure \ref{fig:ex3-model-solution}, we can see that the semantics have changed. The model solution returns \haskell{s} when the precondition does not hold, while this implementation returns \haskell{take n s}.

This is a case in which checking for the precondition leads to a program with different semantics when compared to the model solution. In the context of Ask-Elle, this means that normalizing both programs  results in different normal forms.

\begin{figure}
\centering
\begin{minted}{haskell}
printField n s
    | n < length s  = take n s
    | all isDigit s = padding ++ s
    | otherwise     = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Exercise 3 - Explicit precondition checking; differing semantics}
\label{fig:analysis-precondition-example}
\end{figure}

\subsubsection{Similar semantics}

In some cases, checking for the precondition did not result in different semantics relative to the model solution. Figure \ref{fig:analysis-precondition-similar-semantics} shows a function that explicitly checks for the precondition and returns \haskell{s} when the precondition does not hold.

In this case, the semantics of the program are similar to those of the model solution, but normalizing both still yields different normal forms.

\begin{figure}
\centering
\begin{minted}{haskell}
printField n s
    | n < length s  = s
    | all isDigit s = padding ++ s
    | otherwise     = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Exercise 3 - Explicit precondition checking; similar semantics}
\label{fig:analysis-precondition-similar-semantics}
\end{figure}

\subsubsection{Additional complications}

Since a precondition is nothing more than a logical expression, it can be written in multiple ways. This offers even more challenges, because a precondition that is checked in the code could appear in any form as long as its meaning does not change. In fact, submissions to Exercise 3 sometimes check the precondition using its negation (\haskell{n < length s}), sometimes split the check in three guards (\haskell{n > length s}, \haskell{n == length s} or \haskell{otherwise}) and sometimes do the check in a completely different way.

Additionally, it is possible to implicitly check the precondition without resorting to \haskell{if} expressions or guards. For instance, in Figure \ref{fig:ex3-implicit-precondition-checking} a student calls the \haskell{max} function to ensure that replicate never receives a negative argument. This is unnecessary, since it is guaranteed by the precondition of the function.

\begin{figure}
\centering
\begin{minted}{haskell}
printField n s
    | all isDigit s     = r ++ s
    | otherwise         = s ++ r
    where
        r = replicate a ' '
        a = max 0 (n - length s)
\end{minted}
\caption{Exercise 3 - Implicit precondition checking}
\label{fig:ex3-implicit-precondition-checking}
\end{figure}

\subsection{Normalization up to preconditions}
\label{sec:analysis-precondition-solution}

The ideal solution to the problems outlined above is to integrate the preconditions in our reasoning of semantic equivalence. If we assume that the precondition always holds, then we can ignore the code that is meant to handle the case when the precondition does not hold. More specifically, we can treat such code as dead, because we know it will never be executed.

The main challenge with this approach is that it requires identifying which parts of the code are dead according to the precondition. In the general case, this amounts to solving the halting problem\footnote{Detecting dead code, even without taking preconditions into account, amounts to solving the halting problem. We can prove this by contradiction. Consider a program P that can detect dead code in the general case and a program A that we would like to check for termination. To this purpose, we add a line of code at the end of A. If P says the code is dead, we know that A does not terminate. If P says the code is live, we know that A does terminate.}. Therefore, we limit ourselves to a heuristic that removes pattern matching on the empty list when we know it should be non-empty. This is illustrated by Figure \ref{fig:preconditions-remove-base-case}.

\begin{figure}
\centering
\emph{Before}
\begin{minted}{haskell}
parseTable [] = error "empty list in parseTable"
parseTable xs = map words xs
\end{minted}
\bigskip
\emph{After}
\begin{minted}{haskell}
parseTable xs = map words xs
\end{minted}
\caption{Exercise 1 - Normalization up to preconditions}
\label{fig:preconditions-remove-base-case}
\end{figure}

\section{Lists}

The assignment expects students to manipulate lists by combining list-specific functions. Therefore it is not surprising that many normalization problems come from the domain of lists.

\subsection{Explicit recursion}

Many students fail to use higher-order functions and resort to recursion instead, occasionally reimplementing a higher-order function without realizing. We identified reimplementations of \haskell{map}, \haskell{filter} and \haskell{zip}.

\subsubsection{Function abstraction heuristic}

As an example of a function where the student has reimplemented \haskell{map}, let us consider Figure \ref{fig:ex1-reimplementation-map}.  It is clear that the normal form does not match the model solution in Figure \ref{fig:ex1-model-solution}.

To tackle this problem, we add a heuristic that is able to replace recursive functions by their standard library counterparts. The heuristic detects reimplementations of \haskell{map}, \haskell{filter} and \haskell{zip}.

With this heuristic in place, the function from Figure \ref{fig:ex1-reimplementation-map} is normalized to the same normal form as the model solution.

\begin{figure}
\begin{minted}{haskell}
parseTable = map words
\end{minted}
\caption{Exercise 1 - Model solution}
\label{fig:ex1-model-solution}
\end{figure}

\begin{figure}
\centering
\emph{Student submission}
\begin{minted}{haskell}
parseTable [] = []
parseTable (x:xs) = words x : parseTable xs
\end{minted}
\bigskip
\emph{Normalized version}
\begin{minted}{haskell}
parseTable = fix (\rec xs -> case xs of
        [] -> []
        y : ys -> words y : rec ys
    )
\end{minted}
\caption{Exercise 1 - Reimplementation of map}
\label{fig:ex1-reimplementation-map}
\end{figure}

\subsubsection{Grouping recursive submissions in a single cluster}

The function abstraction heuristic works well for simple functions such as \haskell{map}, \haskell{filter} and \haskell{zip}. However, it is not clear whether more complex cases like \haskell{foldr} can be abstracted by a general-purpose heuristic. In such cases, we give up on trying to remove recursion and focus instead on grouping recursive submissions in a single cluster.

An example of this is Exercise 2. Figure \ref{fig:ex2-model-solutions} shows two model solutions, representing the cluster of submissions using \haskell{foldr} and the cluster using recursion.

This approach works great when the recursive submissions are somewhat similar to each other. In fact, the biggest cluster in Exercise 2 after our improvements consists of recursive submissions and accounts for 35\% of the total submissions.

\begin{figure}
\centering
\emph{Model solution using foldr}
\begin{minted}{haskell}
printLine = foldr (\x xs -> '+' : replicate x '-' ++ xs) "+"
\end{minted}
\bigskip
\emph{Recursive model solution}
\begin{minted}{haskell}
printLine []     = "+"
printLine (x:xs) = "+" ++ replicate x '-' ++ printLine xs
\end{minted}
\caption{Exercise 2 - Model solutions}
\label{fig:ex2-model-solutions}
\end{figure}

Still, there are always creative submissions that refuse to be normalized to the same cluster. Two common problems on this regard are caused by preconditions and by using guards instead of pattern matching. The submission to Exercise 2 in Figure \ref{fig:ex2-reimplementation-map-guards} features both:

\paragraph{Preconditions}

As discussed in Section \ref{sec:preconditions-and-semantics}, preconditions in exercises allow functions with different semantics to be considered correct. Semantic differences are introduced because of variations in the way the exceptional case is handled.

In Exercise 2, the precondition of \haskell{printLine} is that the list cannot be empty. Because of the this, we see a variation between the solution in Figure \ref{fig:ex2-model-solutions} and Figure \ref{fig:ex2-reimplementation-map-guards}. The former returns \haskell{"+"} when the list is empty, while the latter crashes. This means that no amount of semantics-preserving transformations can bring both programs to the same normal form.

% FIXME (if we have time): say that this also causes problems to the map heuristic, because some people reimplement map with a singleton list as base case

\paragraph{Guards and pattern matching}

Using guards instead of pattern matching does not alter the semantics of the program. This means that it is possible to implement a semantics-preserving transformation to replace the guards by pattern matching.

In the example, the student checks whether the list is empty using the \haskell{length} function. This check could clearly be replaced by a \haskell{case} expression that matches on the list, where the empty case jumps to the right-hand side of the first guard and the other case jumps to the second.

We do not implement such a transformation, however, because it seems too ad-hoc. It works only for lists and only when the condition is \haskell{length xs == 0}. Ideally, we would like to have a generalized version, working on other data types as well (such as \haskell{Maybe}) and able to handle a wider range of conditions. Because of time constraints and the low number of submissions that would benefit from such a transformation, we leave it as a candidate for future work.

% Future work: explore transforming guards into pattern matching

% Discussion: this, together with the precondition thing, hints again at the convenience of doing more advanced analysis to remove parts of the program

\begin{figure}
\begin{minted}{haskell}
printLine (w:ws)
    | (length ws == 0) = "+" ++ line ++ "+"
    | otherwise = "+" ++ line ++ printLine ws
    where line = concat (replicate w "-")
\end{minted}
\caption{Exercise 2 - Recursive submission with multiple issues}
\label{fig:ex2-reimplementation-map-guards}
\end{figure}

% \subsection{Redundant base case}

% % Probably need a section about explicit and implicit preconditions
% % All functions described in Assignment I take at least one list as a parameter. From those, all of them work on non-empty list

% Since all functions in the assignment involve manipulating lists, pattern matching on the function parameters is common practice amont the students. Sometimes, this results in redundant pattern matching, as shown in Figure \ref{fig:ex1-redundant-base-case}.

% Fortunately, removing redundant pattern matching is simple in such cases. Therefore we introduce a new transformation that removes the base case for \haskell{map} and \haskell{concatMap}.

% Notice that this transformation has no effect at all in our dataset. This happens because base cases in this form are normalized away by the transformation described in Section \ref{sec:precondition-partial-solutions}. Still, we think it is general-purpose enough to have and expect it to be useful to exercises that do not rely on preconditions.

% \begin{figure}
% \begin{minted}{haskell}
% parseTable [] = []
% parseTable xs = map words xs
% \end{minted}
% \caption{Exercise 1 - Redundant base case}
% \label{fig:ex1-redundant-base-case}
% \end{figure}

% \subsection{Foldr vs foldl}

% Two semantically equivalent programs do not unify if one is defined in terms of \haskell{foldr} and the other in terms of \haskell{foldl}. The same applies to two programs where one uses \haskell{foldr} and the other uses \haskell{foldr} in combination with \haskell{map}. This is illustrated by the table below:

% \begin{center}
% \begin{tabular}{ m{12em} | m{16em} }
% \haskell{foldr (+) 0} & \haskell{foldl (+) 0} \\
% \hline
% \haskell{foldr (+) 0 . map (* 2)} & \haskell{foldr (\x acc -> 2 * x + acc) 0}
% \end{tabular}
% \end{center}

% Using \haskell{foldr} when simpler alternatives exist. Some instances solved by applying laws...

% No solution

\subsection{Desugaring}

Some of the exercises involve using list and string literals. Since the empty string can be expressed as \haskell{""} or \haskell{[]}, this results in different normal forms in otherwise equivalent programs. We also observe variations in the way singleton lists and strings are represented by students, which lead again to different normal forms.

To resolve this issue, we specify a single normal form for list and string literals. We achieve this through the following transformations:

\begin{center}
\begin{tabular}{ m{10em} | m{10em} }
    From & To \\
    \hline
    String literal & List of characters \\
    \hline
    List literal & Sequence of cons
\end{tabular}
\end{center}

Besides the issue of list and string literals, we observe that some students use list comprehensions instead of higher-order functions. This again results in different normal forms in otherwise equivalent programs. To tackle this problem, we add a normalization step that desugars list comprehensions into list literals and higher-order functions. To this purpose, we use the algorithm described in Section 3.11 of the Haskell Report \cite{2010haskell}.

\subsection{List laws}

In many cases, the differences between two semantically-equivalent normal forms can be resolved by a simple rewrite rule. Based on the student submissions, we identify a series of laws and implement them as rewrite rules in Ask-Elle's normalization procedure. They are summarized in Table \ref{tb:list-laws}.

\begin{table}
    \centering
    \begin{tabular}{ m{13em} | m{13em} }
    From & To \\
    \hline
    \haskell{xs ++ []} & \haskell{xs} \\
    \hline
    \haskell{map f . map g} & \haskell{map (f . g)} \\
    \hline
    \haskell{concatMap f . map g} & \haskell{concatMap (f . g)} \\
    \hline
    \haskell{concat (replicate x [e])} & \haskell{replicate x e} \\
    \hline
    \haskell{take n (cycle [e])} & \haskell{replicate x e} \\
    \hline
    \haskell{intercalate []} & \haskell{concat} \\
    \hline
    \haskell{foldr (++) []} & \haskell{concat} \\
    \hline
    \haskell{foldr (:)} & \haskell{flip (++)} \\
    \hline
    \haskell{concat . map} & \haskell{concatMap} \\
    \hline
    \haskell{map id} & \haskell{id} \\
    \hline
    \haskell{concatMap (flip (:) [])} & \haskell{id} \\
    \hline
    \haskell{(!! 0)} & \haskell{head} \\
    \hline
    \haskell{(xs ++ ys) ++ zs} & \haskell{xs ++ (ys ++ zs)} \\
    \hline
    \haskell{transpose . map (map f)} & \haskell{map (map f) . transpose}
    \end{tabular}
    \caption{List laws added to the normalization procedure}
    \label{tb:list-laws}
\end{table}

Besides these laws, we also identify slightly more complex ones that require reasoning at the scope level. We describe them below.

\subsubsection{Simplify concatMap and mapMaybe}

A pattern we observe in some student submissions is using \haskell{concatMap} when \haskell{map} would be sufficient. The same happens with the \haskell{mapMaybe} function. We add the transformations from Table \ref{tb:lists-simplifying-concatmap} to normalize both into \haskell{map}. Notice that \haskell{e} can be any Haskell expression and that it may contain references to \haskell{x}.

\begin{table}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{13em} | >{\centering\arraybackslash}m{13em} }
From & To \\
\hline
\haskell{concatMap (\x -> [e])} & \haskell{map (\x -> e)} \\
\hline
\haskell{mapMaybe (\x -> Just e)} & \haskell{map (\x -> e)}
\end{tabular}
\caption{Simplifying \haskell{concatMap} and \haskell{mapMaybe}}
\label{tb:lists-simplifying-concatmap}
\end{table}

\subsubsection{Turn concatMap into filter}

Another pattern that caused problems with normalization is reimplementing \haskell{filter} in terms of \haskell{concatMap}. The transformation in Figure \ref{fig:lists-rewrite-concatmap-as-filter} solves the problem. Again, \haskell{e} can be any Haskell expression and it may contain references to \haskell{x}.

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{10em} >{\centering\arraybackslash}m{10em} }
From & To \\
\begin{minted}{haskell}
concatMap (\x ->
    if cond x
        then [e]
        else []
    )
\end{minted}
& \haskell{filter cond}
\end{tabular}
\caption{Turn \haskell{concatMap} into \haskell{filter}}
\label{fig:lists-rewrite-concatmap-as-filter}
\end{figure}

% \subsubsection{Split mapMaybe}

% This has no effect on our dataset

% After adding transformations that work on \haskell{map}, it pays off to extract \haskell{fmap} from inside \haskell{mapMaybe}. This way, the normalization procedure can apply more rules instead of getting stuck.

% \begin{figure}[H]
% \centering
% \begin{tabular}{ m{13em} | m{13em} }
%     \haskell{mapMaybe (\x -> fmap f e)} & \haskell{map f . mapMaybe (\x -> e)}
% \end{tabular}
% \end{figure}

% Here, \haskell{e} can be any Haskell expression and it may contain references to \haskell{x}. Also, \haskell{f} can be any expression as long as it does not contain any references to \haskell{x}.

\subsection{List indexing}

A particularly problematic pattern we observe in a few student submissions is list indexing. While inoffensive on its own, list indexing becomes a normalization nightmare when used to write imperative-like code. Consider, for instance, the submission to Exercise 2 in Figure \ref{fig:ex2-list-indexing}. Even though the semantics are the same as a properly functional implementation (as in Figure \ref{fig:ex2-model-solutions}), the enormous syntactic differences make it very difficult for both to reach the same normal form.

In the particular example we are considering, we can see that the list comprehension is reimplementing \haskell{map}. While it would be possible to write a transformation that applies to this particular case, it seems too ad-hoc. Also, the submissions that would benefit from this are too few compared to the effort of implementing such a general-purpose transformation. Therefore we leave this problem as a candidate for future work.

% Future work / discussion

\begin{figure}
\centering
\begin{minted}{haskell}
printLine xs = "+" ++ intercalate "+" lines  ++ "+"
    where
       columns = length xs
       lines = [replicate (xs !! index) '-'
                | index <- [0..(columns-1)]]
\end{minted}
\caption{Exercise 2 - List indexing}
\label{fig:ex2-list-indexing}
\end{figure}

\section{Booleans}

Given the crucial role of booleans in the control flow of a program, normalization problems on this domain have a far reaching effect. While there are less issues compared to lists, we still identify and address many of them.

\subsection{Guard rewriting}

One of Ask-Elle's normalization steps rewrites guards as \haskell{if} expressions. This is only possible if the guards are total, as illustrated by Figure \ref{fig:ex3-total-guards}.

\begin{figure}
\centering
\emph{Before}
\begin{minted}{haskell}
printField n s
    | all isDigit s = padding ++ s
    | otherwise     = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\smallskip
\emph{After}
\begin{minted}{haskell}
printField n s = if all isDigit s then padding ++ s
                                  else s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Total guards are rewritten as a top-level \haskell{if}}
\label{fig:ex3-total-guards}
\end{figure}

Ask-Elle knows that guards are total if the last one is \haskell{True} or \haskell{otherwise}. While this heuristic works well in many cases, it fails when a program uses total guards expressed in terms of a condition and its negation (see Figure \ref{fig:ex3-total-guards-not}). For this reason, we enhance Ask-Elle's guard rewriting to support this new way of expressing total guards.

\begin{figure}
\begin{minted}{haskell}
printField n s
    | all isDigit s       = padding ++ s
    | not (all isDigit s) = s ++ padding
    where padding = replicate (n - length s) ' '
\end{minted}
\caption{Total guards using \haskell{not}}
\label{fig:ex3-total-guards-not}
\end{figure}

\subsection{Boolean laws}

Similar to lists, there are many cases in which the differences between two semantically-equivalent normal forms can be resolved by a simple rewrite rule. Table \ref{tb:boolean-laws} summarizes the laws we implement as rewrite rules in Ask-Elle's normalization procedure.

\begin{table}
    \centering
    \begin{tabular}{ m{15em} | m{11em} }
    From & To \\
    \hline
    \haskell{(==) True} & \haskell{id} \\
    \hline
    \haskell{(&&) True} & \haskell{id} \\
    \hline
    \haskell{(==) False} & \haskell{not} \\
    \hline
    \haskell{foldr (&&) True} & \haskell{and} \\
    \hline
    \haskell{all id} & \haskell{and} \\
    \hline
    \haskell{and . map f} & \haskell{all f} \\
    \hline
    \haskell{if cond then True else False} & \haskell{cond} \\
    \hline
    \haskell{if not cond then y else x} & \haskell{if cond then x else y}
    \end{tabular}
    \caption{Boolean laws added to the normalization procedure}
    \label{tb:boolean-laws}
\end{table}

\subsection{Function negation}

Some Haskell functions are equivalent to the negation of other functions. For instance, \haskell{isNothing} is equivalent to \haskell{not . isJust}. This is important knowledge, as some of the transformations described above operate on expressions that involve the \haskell{not} function. From this perspective, expressing a function in terms of \haskell{not} increases the chances that a program can be normalized further. Table \ref{tb:booleans-fn-negation} shows new rewriting transformations directed towards this goal.

\begin{table}
\centering
\begin{tabular}{ m{13em} | m{13em} }
From & To \\
\hline
\haskell{notElem} & \haskell{not . elem} \\
\hline
\haskell{isNothing} & \haskell{not . isJust}
\end{tabular}
\caption{Function negation}
\label{tb:booleans-fn-negation}
\end{table}

As an example of how this helps drive normalization further, consider Figure \ref{fig:boolean-negation-example}. The original program, based on \haskell{isNothing}, ends up in the same normal form as a similar program based on \haskell{isJust}.

\begin{figure}
\begin{tabular}{ m{16em} m{10em} }
\haskell{if isNothing x then y else z} & \emph{rewrite in terms of \texttt{not}} \\
%\hline
\haskell{if not (isJust x) then y else z} & \emph{switch \texttt{if} branches} \\
%\hline
\haskell{if isJust x then z else y} &
\end{tabular}
\caption{Interaction between function negation and boolean laws}
\label{fig:boolean-negation-example}
\end{figure}

% \subsection{Nested if statements}

% it may be interesting to talk about this, as it gives us a reason to talk about the need for more advanced analysis later on.

% Nested if statements that check for the same condition.

\section{Maybe}

Exercises 7 and 8 rely on the \haskell{Maybe} type to handle edge cases. Students are expected to use functions from the standard library to manipulate \haskell{Maybe} values. This offers room for multiple issues.

\subsection{Function abstraction through rewrite rules}

One of the main problems we observe is caused by function reimplementation. Many students write their own version of \haskell{fromMaybe}, \haskell{fromJust}, \haskell{isJust}, \haskell{isNothing} and \haskell{fmap}.

In most cases, functions can be abstracted through a simple rewrite rule, as illustrated by Table \ref{tb:maybe-laws}. We implement this in a similar way to list and boolean laws (tables \ref{tb:list-laws} and \ref{tb:list-laws} respectively).

\begin{table}
\centering
\begin{tabular}{ m{13em} | m{13em} }
    From & To \\
    \hline
    \haskell{(==) Nothing} & \haskell{isNothing} \\
    \hline
    \haskell{(/=) Nothing} & \haskell{isJust} \\
    \hline
    \haskell{maybeToList x == []} & \haskell{isNothing x} \\
    \hline
    \haskell{maybeToList x /= []} & \haskell{isJust x} \\
    \hline
    \haskell{maybeToList x !! 0} & \haskell{fromJust x} \\ % Interesting... How does this interact with head unfolding? There is a race here. If unfolding is applied first, will this still work?
    \hline
\begin{minted}{haskell}
case m of
    Nothing -> d
    Just x  -> x
\end{minted}
    & \haskell{fromMaybe d m}
\end{tabular}
\caption{\haskell{Maybe} laws}
\label{tb:maybe-laws}
\end{table}

The case of \haskell{fmap} is a bit more complex, as shown in Figure \ref{fig:maybe-abstract-fmap}. On the left-hand side, \haskell{e} is an arbitrary expression that may or may not use the \haskell{x} variable. On the right-hand side, \haskell{f} is a lambda with a single parameter, where the body is the \haskell{e} expression with all occurrences of \haskell{x} replaced by its parameter. Figure \ref{fig:maybe-abstract-fmap-example} offers an example.

\begin{figure}
\begin{tabular}{ m{13em} | m{13em} }
\begin{minted}{haskell}
case m of
    Nothing -> Nothing
    Just x -> e
\end{minted}
& \haskell{fmap f m}
\end{tabular}
\caption{Abstracting \haskell{fmap} for \haskell{Maybe}}
\label{fig:maybe-abstract-fmap}
\end{figure}

\begin{figure}
\begin{tabular}{ m{13em} | m{13em} }
\begin{minted}{haskell}
case m of
    Nothing -> Nothing
    Just x -> x + 1
\end{minted}
& \haskell{fmap (\a -> a + 1) m}
\end{tabular}
\caption{Example of abstracting \haskell{fmap} for \haskell{Maybe}}
\label{fig:maybe-abstract-fmap-example}
\end{figure}

\subsection{Unfolding the maybe function}

Some student submissions use the \haskell{maybe} function instead of \haskell{case} when manipulating \haskell{Maybe} values. While abstracting \haskell{maybe} from \haskell{case} expressions is possible, unfolding \haskell{maybe} yields even less clusters when normalizing. Therefore we add an unfolding transformation to Ask-Elle's normalization, according to the definition of the function in \ref{fig:maybe-definition}.

% Is this a hint of a deeper principle? Unfold as long as there are no laws, abstract if you want to apply laws?

\begin{figure}
\centering
\begin{minted}[xleftmargin=0.3\textwidth]{haskell}
maybe d f m = case m of
    Nothing -> d
    Just x -> f x
\end{minted}
\caption{Definition of \haskell{maybe}}
\label{fig:maybe-definition}
\end{figure}

\subsection{The isJust / fromJust combination}

Another normalization problem is caused by the combination of \haskell{isJust} and \haskell{fromJust}. With this pattern, a student first checks whether a value is \haskell{Just} or \haskell{Nothing}. In the first case, the program extracts the value using \haskell{fromJust} and passes the result to an expression. In the latter case, a different branch of the code is executed. Figure \ref{fig:maybe-isjust-fromjust} illustrates the problem and proposes an idiomatic alternative.

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{13em} >{\centering\arraybackslash}m{13em} }
isJust / fromJust & Idiomatic alternative \\
\begin{minted}{haskell}
if isJust m
    then f (fromJust m)
    else d
\end{minted}
& \begin{minted}{haskell}
case m of
    Nothing -> d
    Just x -> f x
\end{minted}
\end{tabular}
\caption{The \haskell{isJust} / \haskell{fromJust} combination}
\label{fig:maybe-isjust-fromjust}
\end{figure}

Ideally, the normalization procedure should be able to rewrite the \haskell{isJust} pattern as a \haskell{case} expression. Such a transformation would apply to expressions in the form \haskell{if isJust m then e else e'}, replacing all occurrences of \haskell{fromJust m} in \haskell{e} by the unwrapped value. Because of its interaction with other transformations, adding this normalization step is more complex than it seems. Considering its expected low impact, we leave it as a candidate for future work.

\subsection{Disguised isJust / fromJust combination}

We observe also a variation of the \haskell{isJust} / \haskell{fromJust} pattern, where students use \haskell{fromMaybe} with a magic default value, which is later checked by an if statement. In case the output of \haskell{fromMaybe} turns out to be the magic value, then the original \haskell{Maybe} object was \haskell{Nothing}. Otherwise, it was \haskell{Just}. The resulting code is presented in Figure \ref{fig:maybe-isjust-fromjust-disguised}.

\begin{figure}
\centering
\begin{minted}{haskell}
let x = fromMaybe (-1) m
in if x /= (-1) then f x else d
\end{minted}
\caption{Disguised \haskell{isJust} / \haskell{fromJust} combination}
\label{fig:maybe-isjust-fromjust-disguised}
\end{figure}

In this case, a normalization step that transforms the expression into a \haskell{case} is much more complex, for two reasons:

\begin{itemize}
    \item The pattern assumes that the value bound to \haskell{m} is never \haskell{Just (-1)};
    \item Checking whether the magic value was returned can be done in multiple ways (e.g. students use \haskell{(==)}, \haskell{(/=)} and even \haskell{(>)}).
\end{itemize}

The first point implies that a semantics-preserving transformation must be able to prove that the value bound to \haskell{m} is never \haskell{Just (-1)}. The second point makes this problem even worse. For instance, if a student writes \haskell{x > (-1)} as the \haskell{if} condition, the normalizer would also need to prove that \haskell{m} can never contain any number lower than \haskell{-1}. Inferring this kind of knowledge requires advanced program analysis and is beyond the scope of this research.

\section{Patterns}

Pattern matching is at the core of the Haskell language. Since patterns are very expressive, there are many different ways to write semantically equivalent programs. As we have seen before, this is a source of problems from a normalization perspective.

\subsection{Pattern simplification}

A straightforward simplification is to remove wildcard patterns bound to a name. That is, a pattern in the form \haskell{x@_} is simplified to \haskell{x}. Since a name matches the same values as a wildcard, this transformation is sound.

Another useful simplification is to remove nested \emph{as} patterns. For instance, a pattern like \haskell{xs@ys@(z:zs)} could be simplified to \haskell{xs@(z:zs)}, thereby removing the binding to \haskell{ys}. Note that, in this case, additional care must be taken to rename all usages of \haskell{ys} to \haskell{xs}.

\subsection{Unfold functions that pattern match}
\label{sec:patterns-unfolding}

Another source of syntactic differences are functions that use pattern matching on their parameters, with an undefined case when the pattern does not match the definition. This allows writing the same program by calling such functions or by using \haskell{case} or \haskell{let} inline. Table \ref{tb:patterns-unfolding} shows the transformations we add to improve normalization in these cases.

\begin{table}
\centering
    \begin{tabular}{ m{6em} | m{13em} }
    From & To \\
    \hline
    \haskell{head xs} & \haskell{let (x : _) = xs in x} \\
    \hline
    \haskell{tail xs} & \haskell{let (_ : ys) = xs in ys} \\
    \hline
    \haskell{fst x} & \haskell{let (a, _) = x in a} \\
    \hline
    \haskell{snd x} & \haskell{let (_, b) = x in b} \\
    \hline
    \haskell{fromJust m} & \haskell{let (Just x) = m in x}
    \end{tabular}
    \caption{Unfolding functions that pattern match}
    \label{tb:patterns-unfolding}
\end{table}

\subsection{Nested patterns and pattern lifting}
% \label{sec:patterns-nested}

Nested pattern matching is another source of syntactic differences that cause normalization problems. Sometimes it originates from student submissions and in other cases it is produced by other normalization steps (e.g. the unfolding transformation mentioned in Section \ref{sec:patterns-unfolding}).

Ideally, we would like to collapse nested pattern matches into one, which then becomes the normal form. Figure \ref{fig:patterns-nested-matching} shows an example of this, where the program to the left uses nested pattern matching and the one to the right does not. Notice, by the way, how the pattern matching on the left corresponds to an unfolded version of \haskell{head}.

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{17em} >{\centering\arraybackslash}m{13em} }
    Nested & Collapsed \\
    \begin{minted}{haskell}
    case a of
        [] -> []
        xs -> let (y : _) = xs
              in e
    \end{minted}
    &
    \begin{minted}{haskell}
    case a of
        [] -> []
        xs@(y : _) -> e
    \end{minted}
\end{tabular}
\caption{Nested pattern matching}
\label{fig:patterns-nested-matching}
\end{figure}

\subsubsection{Introducing pattern lifting}

Our proposed solution to the problem of nested pattern matching is \emph{pattern lifting}. This mechanism detects pattern matches on a variable that has been bound in a previous match. Then, it lifts the nested binding and merges it with the pattern it comes from.

Consider again Figure \ref{fig:patterns-nested-matching} as an example. We can see that \haskell{xs} is bound in the second alternative of the \haskell{case} and that \haskell{y} is bound by matching on \haskell{xs}. This means we can lift the pattern where \haskell{y} is bound, thereby merging the \haskell{xs} and \haskell{(y : _)} patterns into one. As you can see on the right of the figure, the resulting pattern is \haskell{xs@(y : _)}.

\subsubsection{Conservative and aggressive variants}

Pattern lifting as described above turns out to be unsound, as shown by the counterexample in Figure \ref{fig:pattern-lifting-unsound}. In the original program, the head of the list is only taken if the list is not empty. However, pattern lifting moves the match upwards, thereby changing the semantics of the program. In the resulting code, an attempt to access the head of the list will be made even when the list is empty. We call this aggressive pattern lifting.

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{17em} >{\centering\arraybackslash}m{10em} }
Before & After \\
\begin{minted}{haskell}
let xs = e
in if xs == []
    then let (y:_) = xs in y
    else 42
\end{minted}
& \begin{minted}{haskell}
let xs@(y:_) = e
in if xs == []
    then y
    else 42
\end{minted}
\end{tabular}
\caption{Unsound pattern lifting}
\label{fig:pattern-lifting-unsound}
\end{figure}

To prevent this problem, we define a conservative version of pattern lifting, which only supports irrefutable patterns. Irrefutable patterns are patterns that always match, like variables and wildcards. Also tuples containing other irrefutable patterns are themselves irrefutable. The same is valid for \emph{as} patterns. With this constraint, pattern lifting is always semantics-preserving.

As expected, conservative pattern lifting results in a less effective normalization in comparison to aggressive pattern lifting. Table \ref{tb:patterns-lifting-effectiveness} shows the difference in the amounts of clusters depending on the pattern lifting mode used. Exercises where there is no difference are ignored.

\begin{table}
\centering
\begin{tabular}{ m{6em} | m{6em} | m{6em} }
Exercise & Conservative & Aggressive \\
\hline
1 & 3 & 2 \\
\hline
4 & 13 & 12 \\
\hline
6 & 17 & 16 \\
\hline
7 & 30 & 28 \\
\hline
8 & 20 & 18
\end{tabular}
\caption{Effectiveness of pattern lifting}
\label{tb:patterns-lifting-effectiveness}
\end{table}

\subsubsection{In defense of aggressive pattern lifting}

As mentioned above, aggressive pattern lifting is unsound. This means that it may change the meaning of a program, forcing a pattern match earlier than specified in the original code.

In the context of normalization, this unsoundness means that an incorrect program could have the same normal form as a correct one. Allowing unsound transformations could lead Ask-Elle to say that two programs are equivalent, when in fact they are not. This is the case illustrated by Figure \ref{fig:pattern-lifting-unsound}.

We think, however, that an incorrect program with the necessary characteristics is very unlikely to pass a basic test suite. Such a program would need to pattern match too early on a value, leading to an easy to detect crash. In light of this, we treat aggressive pattern lifting as a sound transformation in practice, even though it is technically unsound.

% In fact, our test suite did not find any single program that would have caused problems to pattern lifting.

\subsection{Tuple deconstruction and reconstruction}

We oberve another normalization issue where students deconstruct and reconstruct a tuple instead of matching on its expression. This results in code like \haskell{let (a, b) = e in f (a, b)}, when \haskell{f e} would have been sufficient. We add a transformation to remove pattern matching in such a case.

\subsection{Tuple unrolling}

Ask-Elle's normalization inlines bindings to names, not to patterns. A consequence of this is that it will fail to inline names that are bound inside a tuple pattern. Below we consider the problem from the perspectives of \haskell{let} and \haskell{case}, and we present a new transformation to solve it.

\subsubsection{Let}

In the case of \haskell{let}, Figure \ref{fig:patterns-tuple-unrolling-let} shows on the left a group of variables being bound inside a tuple pattern. On the right is an equivalent version, where the tuple has been unrolled into separate bindings, one for each variable. We enhance Ask-Elle with a normalization step that performs this transformation.

% Note that, in the figure, \haskell{a}, \haskell{b} and \haskell{c} can be arbitrary patterns.

% FIXME (if we have time): how does this interact with recursive let?

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{14em} >{\centering\arraybackslash}m{8em}}
Original & Unrolled \\
\begin{minted}{haskell}
let (a, b, c) = (x, y, z)
in e
\end{minted}
& \begin{minted}{haskell}
let a = x
    b = y
    c = z
in e
\end{minted}
\end{tabular}
\caption{Tuple unrolling for \haskell{let}}
\label{fig:patterns-tuple-unrolling-let}
\end{figure}

\subsubsection{Case}

Tuple unrolling for \haskell{case} is a bit more complicated than for \haskell{let}, as the patterns may influence the control flow of the program. Figure \ref{fig:patterns-tuple-unrolling-case} shows on the left a \haskell{case} that illustrates the problem. It is clear that we cannot unroll the binding to \haskell{a}, as it is being used to choose which alternative to execute. Still, it is possible to unroll \haskell{b} and \haskell{c}, as shown on the right of the figure.

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{14em} >{\centering\arraybackslash}m{8em} }
Original & Unrolled \\
\begin{minted}{haskell}
case (a, b, c) of
    ([], _, _) -> []
    (x : xs, y, z) -> e
\end{minted}
& \begin{minted}{haskell}
let y = b
    z = c
in case a of
    [] -> []
    x : xs -> e
\end{minted}
\end{tabular}
\caption{Tuple unrolling for \haskell{case}}
\label{fig:patterns-tuple-unrolling-case}
\end{figure}

\subsection{Other case transformations}

Additional transformations to simplify \haskell{case} expressions include rewriting a single-alternative \haskell{case} as a \haskell{let} (Figure \ref{fig:patterns-rewrite-case-let}), removing the last alternative if it leads to \haskell{undefined} (Figure \ref{fig:patterns-remove-undefined-alt}) and removing unreachable alternatives (Figure \ref{fig:patterns-remove-unreachable-alt}).

In the latter case, we use a conservative heuristic. An alternative is unreachable if the previous alternative matches on a:

\begin{itemize}
\item Wildcard;
\item Variable;
\item Tuple of wildcards or variables.
\end{itemize}

\begin{figure}
\centering
\begin{tabular}{>{\centering\arraybackslash}m{10em} >{\centering\arraybackslash}m{10em} }
From & To \\
\begin{minted}{haskell}
case xs of
    y:ys -> e
\end{minted}
& \begin{minted}{haskell}
let (y:ys) = xs in e
\end{minted}
\end{tabular}
\caption{Rewriting \haskell{case} as \haskell{let}}
\label{fig:patterns-rewrite-case-let}
\end{figure}

\begin{figure}
\centering
\begin{tabular}{>{\centering\arraybackslash}m{12em} >{\centering\arraybackslash}m{8em} }
From & To \\
\begin{minted}{haskell}
case xs of
    []   -> e
    y:ys -> undefined
\end{minted}
& \begin{minted}{haskell}
case xs of
    [] -> e
\end{minted}
\end{tabular}
\caption{Removing last alternative leading to \haskell{undefined}}
\label{fig:patterns-remove-undefined-alt}
\end{figure}

\begin{figure}
\centering
\begin{tabular}{>{\centering\arraybackslash}m{8em} >{\centering\arraybackslash}m{8em} }
From & To \\
\begin{minted}{haskell}
case xs of
    ys -> e
    zs -> e'
\end{minted}
& \begin{minted}{haskell}
case xs of
    ys -> e
\end{minted}
\end{tabular}
\caption{Removing unreachable alternative}
\label{fig:patterns-remove-unreachable-alt}
\end{figure}

\section{Miscellaneous}

Besides the domain-specific transformations mentioned above, we also add transformations that are not tied to a particular domain. Simple ones include inlining of non-recursive functions and dead code removal. The rest is described below.

\subsection{Beta reduction}

Since many of our transformations involve abstracting functions, it is likely that generalized beta reduction would result in infinite loops within the normalization procedure. Therefore we only allow beta reduction of whitelisted functions: \haskell{id}, \haskell{const}, \haskell{++}, \haskell{map}, \haskell{concat}, \haskell{foldr} and \haskell{flip}.

\subsection{Order arguments in commutative functions}

By definition, commutative functions return the same result independently of the order of their arguments. From a normalization perspective, this is a source of problems, because it results in programs which are semantically equivalent but syntactically different. For this reason, we add a transformation that enforces an order in the arguments passed to a commutative function.

\subsection{Abstract and unfold functions}

Similar to domain-specific transformations, we abstract and unfold general purpose functions. The transformations are summarized in Table \ref{tb:misc-abstract-unfold}.

Notice that the transformation involving \haskell{(>>>)} is possible because Ask-Elle restricts the operator to only work on functions. Any attempt to use it on different types results in a compile error.

\begin{table}
\centering
\begin{tabular}{ m{6em} | m{6em} }
From & To \\
\hline
\haskell{\x -> x} & \haskell{id} \\
\hline
\haskell{(>>>)} & \haskell{flip (.)}
\end{tabular}
\caption{Abstracting and unfolding general purpose functions}
\label{tb:misc-abstract-unfold}
\end{table}

\subsection{Transformations involving flip}

Besides beta-reducing \haskell{flip}, we add a transformation to remove it whenever it is applied to a commutative function. Since commutative functions do not care about the order of the arguments, removing \haskell{flip} is semantics-preserving.

Another transformation involving \haskell{flip} is switching the order of the parameters when it is applied to a lambda. This is illustrated by figure \ref{fig:misc-flip-lambda}.

\begin{figure}
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{12em} >{\centering\arraybackslash}m{12em} }
From & To \\
\haskell{flip (\x y -> e)} & \haskell{\y x -> e}
\end{tabular}
\caption{Swith the parameter order in a lambda when applying \haskell{flip}}
\label{fig:misc-flip-lambda}
\end{figure}

\subsection{Eta reduction}

% Limitations to eta reduction (mention them later if we have time)

We enhance the eta-reduction algorithm by allowing it to insert \haskell{flip} when necessary. Figure \ref{fig:misc-eta-flip} shows the result of applying transformation to one of the student submissions.

\begin{figure}
\centering
\emph{Before}
\begin{minted}{haskell}
printLine xs =
    "+" ++ intercalate "+" (map (\x -> replicate '-' x) xs)
        ++ "+"
\end{minted}
\smallskip
\emph{After}
\begin{minted}{haskell}
printLine xs =
    "+" ++ intercalate "+" (map (flip replicate '-') xs)
        ++ "+"
\end{minted}
\caption{Flip-aware eta-reduction}
\label{fig:misc-eta-flip}
\end{figure}

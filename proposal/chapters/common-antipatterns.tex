\chapter{A first take on style anti-patterns}
\label{sec:first-take}

As part of improving Ask-Elle, we need to identify the style issues that cause program unification to fail. For this purpose, we analyze a dataset of 111 correct submissions to the first assignment of the functional programming course at Universiteit Utrecht. The assignment requires implementing 8 functions, which translate to 8 Ask-Elle exercises. This means that we get 888 programs we can analyze.

Measuring the effectiveness of Ask-Elle's unification is done on a per-exercise basis. For each exercise, we take the 111 submissions, normalize them and cluster them in groups that have the same normal form. Since all submissions are correct programs, an ideal normalization strategy should result in a few big clusters, which means that all similar programs have been transformed to the same normal form. This is equivalent to saying that Ask-Elle should be able to match many programs with a small number of model solutions.

\section{Tooling}

We develop a batch tool to:

\begin{itemize}
    \item Normalize all submissions of an exercise;
    \item Identify groups of submissions that have the same normal form;
    \item Output relevant statistics.
\end{itemize}

Since some students use list comprehensions, which are not supported in Ask-Elle, we add support for them in our batch tool. Besides this, we add support for using functions that are defined outside of the prelude, as some exercises require that feature.

\section{Style anti-patterns in exercise 1}

Exercise 1 consists of implementing the function \texttt{parseTable}. Below is a possible model solution:

\begin{minted}{haskell}
parseTable :: [String] -> [[String]]
parseTable = map words
\end{minted}

Using the tool we developed, we feed the 111 solutions to Ask-Elle. We cluster the solutions according to their normal form and identify 15 clusters of varying sizes. The three biggest ones contain submissions that are variants of the following functions:

\begin{enumerate}
\item \mintinline{haskell}{parseTable = map words} (73 elements)
\item \mintinline{haskell}{parseTable xs = map words xs} (13 elements)
\item \mintinline{haskell}{parseTable xs = [words x | x <- xs]} (8 elements)
\end{enumerate}

Besides these groups, there are 12 other groups containing a total of 17 submissions. We identify a series of style-issues that limit the extent to which some programs are normalized.

% Using the tool we developed, we feed the 888 solutions to Ask-Elle. For each exercise, we cluster the solutions according to their normal form, identify the amount of clusters and classify them according to their size. While our tool identifies more than 300 clusters, this proposal focuses only on exercise 1, which contains 15 clusters.

% The table below shows, for each exercise, the total amount of groups. It also shows their size, starting with singleton groups up to groups consisting of more than 64 programs. Note that larger groups are better, since they handle more submissions.

% \begin{tabular}{l l l l l l l l l l}
%     Exercise number & Groups & 1     & 2   & 3-4 & 5-8 & 9-16 & 17-32 & 33-64 & >64 \\
%     1               & 15     &  9    &  2  &  1  &  1  &  1  &  0  &  0  &  1       \\
%     2               & 64     &  47   &  8  &  6  &  2  &  0  &  1  &  0  &  0       \\
%     3               & 51     &  39   &  8  &  1  &  0  &  2  &  1  &  0  &  0       \\
%     4               & 41     &  30   &  3  &  4  &  3  &  0  &  0  &  1  &  0       \\
%     5               & 43     &  28   &  2  &  9  &  1  &  2  &  1  &  0  &  0       \\
%     6               & 107    &  103  &  4  &  0  &  0  &  0  &  0  &  0  &  0       \\
%     7               & 96     &  85   &  8  &  3  &  0  &  0  &  0  &  0  &  0       \\
%     8               & 87     &  76   &  6  &  3  &  2  &  0  &  0  &  0  &  0
% \end{tabular}

\subsection{Redundant pattern matching}

Four submissions were separated from the big groups because they performed unnecessary pattern matching. They are variations of the code below:

\begin{minted}{haskell}
parseTable [] = []
parseTable xs = map words xs
\end{minted}

\subsection{Reimplementation of map}

Two of the submissions consist of a specialized reimplementation of map, following the pattern below:

\begin{minted}{haskell}
parseTable [] = []
parseTable (x:xs) = words x : parseTable xs
\end{minted}

While the function is semantically correct, it would be clearer to directly use \texttt{map}. This issue is not specific to our dataset, as can be deduced from the fact that it is recognized by HLint.

\subsection{List anti-patterns}

Besides the submissions mentioned above, there are three other submissions that reimplement map, but present additional problems. Namely, that they make use of the list anti-patterns shown below.

\begin{minted}{haskell}
-- Concat with a singleton list on the left
parseTable [] = []
parseTable (x:xs) = [words x] ++ parseTable xs

-- Appending to an empty list instead of using a list literal
parseTable [] = []
parseTable (x:xs) = (words x : []) ++ parseTable xs

-- Using head and tail instead of pattern matching on xs
parseTable [] = []
parseTable xs = words (head xs) : parseTable (tail xs)
\end{minted}

The first two programs are recognized by HLint, but not the third, because HLint does not consider it bad style to use head and tail. However, these functions use partial pattern matching under the hood and cause crashes whenever the argument is the empty list.

% Mention the safe library? https://hackage.haskell.org/package/safe

\subsection{Other normalization issues}

Besides the style issues mentioned above, there are other normalization issues. We list them below:

\begin{itemize}
    \item Lack of dead code removal: some student programs include dead bindings and dead branches, which are not present in most other solutions. Since normalization does not remove them, unification always fails in this case.
    \item Lack of irrelevant code removal: the description of the assignment states that the \texttt{parseTable} function always receives a non-empty list as parameter. However, some students add a match for the empty case and raise an error, as shown in Figure \ref{fig:irrelevant-code-error}. Again, most other solutions avoid such code, so this causes unification failure.
    \item Lack of inlining: some students use auxiliary functions that are absent in most other solutions. This prevents their submissions from being part of the bigger clusters.
    \item Unnecessary difference between complete and partial application: \texttt{parseTable = map words} and \texttt{parseTable xs = map words xs} are not considered equivalent under normalization. This results in two program clusters instead of one.
\end{itemize}

\begin{figure}[H]
\begin{minted}{haskell}
parseTable [] = error "Empty list"
parseTable xs = map words xs
\end{minted}
\caption{Irrelevant code in student submission}
\label{fig:irrelevant-code-error}
\end{figure}

% \subsection{Irrelevant code elimination}

% Two of the programs ended up in their own singleton group because of having an unnecessary branch that calls the error function. Instead of the model solution discussed above, they implemented the function as shown below:

% Removing the branch that ends up calling \texttt{error} would have enabled this function to be recognized as part of one of the bigger groups. In principle, such a transformation is not semantics-preserving. However, the definition of the exercise stated that the parameter would never be the empty list. This is a case of *irrelevant code elimination*, as described by Brown and Thompson \cite{2007brown}.

% FIXME: how do we know that cutting a branch is OK? We should mention static analysis here, since that is necessary to detect that a branch is unreachable according to the definition of the problem at hand. Maybe cite this \cite{2002vaucheret}

\section{Adding program transformations}

Based on the results of our analysis, we add the following transformations to Ask-Elle's normalization mechanism:

\begin{itemize}
    \item Remove redundant pattern matching;
    \item Rewrite reimplementations of map to call the map function instead;
    \item Normalize list creation, append and concatenation;
    \item Replace calls to head and tail by pattern matching;
    \item Inline all non-recursive bindings;
    \item Remove dead code;
    \item Remove irrelevant code;
    \item Eta reduce top-level functions.
\end{itemize}

[FIXME 1: explain why removing irrelevant code is a good idea, or remove it and say that our dead code removal takes the specification into account, meaning that we also remove code that is dead according to the specification]

[FIXME 2: add references to the previous transformations in the literature]

We validate the resulting normalization procedure through property-based testing. Each student program is normalized and the result tested against QuickCheck. This way, we can increase our confidence in the thought that normalization is indeed semantics-preserving.

\section{Results}

Adding these transformations causes 109 of the 111 solutions to be clustered in two big groups:

\begin{enumerate}
    \item \mintinline{haskell}{parseTable = map words} (99 elements)
    \item \mintinline{haskell}{parseTable xs = [words x | x <- xs]} (10 elements)
\end{enumerate}

From the remaining two submissions, one uses a function from an external package and is therefore expected to fail unification with the rest. The other submission is correct, but could not be normalized because it presents two edge cases. Figure \ref{fig:exercise1-two-edge-cases} shows the code in question, followed by an explanation of the problem in more detail.

\begin{figure}[H]
\begin{minted}{haskell}
parseTable []     = [[]]
parseTable [x]    = [words x]
parseTable (x:xs) = words x : parseTable xs
\end{minted}
\caption Two edge cases to our normalization procedure
\label{fig:exercise1-two-edge-cases}
\end{figure}

According to our definition of code irrelevance, the base case of this function should be removed. The specification says that the function parameter will never be the empty list, therefore we can treat that part of the function as dead code. However, our heuristic to detect irrelevant code fails in this edge case.

Even after removing the base case, a next step would be required to rewrite the function as a map. In the general case, this transformation is not semantics-preserving, because map does handle the case of the empty list, as shown below.

\begin{minted}{haskell}
-- Before, empty list raises an error
parseTable [x]    = [words x]
parseTable (x:xs) = words x : parseTable xs

-- After, empty list returns empty list
parseTable xs = map words xs
\end{minted}

Still, the transformation above can be considered semantics-preserving in our case, as long as the specification is satisfied. Assuming that the empty list is outside of the domain of the function, the semantics of both versions are equivalent. Unfortunately, our map transformation heuristic does not handle a complex case such as this. That would require reasoning about the interaction between the domain of the function and its semantics.

% The solution here would be to recognize and refactor those anti-patterns. Regarding the previous code examples, the following refactorings would be suitable:

% \begin{itemize}
%     \item Replace \texttt{[x] ++ xs} by \texttt{x : xs}
%     \item Replace \texttt{x : []} by \texttt{[x]}
%     \item Introduce pattern matching whenever the combination of \texttt{head} and \texttt{tail} is used, so \texttt{head xs} can become \texttt{x} and \texttt{tail xs} is replaced by \texttt{xs}.
% \end{itemize}

\section{Conclusion}

Analyzing the student solutions to Exercise 1 reveals several issues that cause Ask-Elle's program unification to fail. Most issues are caused by bad style in student programs, but some of them stem from implementation details. The problems are almost entirely alleviated by adding more semantics-preserving transformations to the normalization procedure.

The improvement is clearly visible. Before the changes, Ask-Elle would recognize 85\% of the submissions as correct, based on 3 model solutions. Now it recognizes 98\% of the submissions as correct, using only 2 model solutions.

% The effect of adding the new program transformations is reflected in the table below:

% \begin{tabular}{l l l l l l l l l l}
%              & Groups & 1     & 2   & 3-4 & 5-8 & 9-16 & 17-32 & 33-64 & >64 \\
%     Before   & 15     & 9     & 2   & 1   & 1   &  1   & 0     & 0     & 1   \\
%     After    & 4      & 2     & 0   & 0   & 0   &  1   & 0     & 0     & 1
% \end{tabular}

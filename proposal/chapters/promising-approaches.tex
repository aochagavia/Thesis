\chapter{Promising approaches}

\subsection{Adding transformations}

The measurements described in the previous section focus only on the effect of a transformation. From this perspective, there is no distinction between a transformation that is tailored to our dataset and one that is applicable to a broader range of programs. Since the goal of this project is to improve Ask-Elle's normalization in the general case, it is crucial to avoid ad-hoc transformations. For this purpose, we only consider adding a transformation when it is:

\begin{itemize}
    \item Mentioned in the literature or;
    \item Recognized as general-purpose by a group of experts.
\end{itemize}

Improving strategy generation and normalization.

\section{Diagnosing failure to give hints}

Failure to give hints may happen because of different reasons:

Normalization didn't do a good job to correct small syntactical differences

The strategy didn't contemplate the path taken by the student

As we saw above, this causes problems when attempting to provide hints for a program that diverges too much from its model solution. Let us consider again the recursive \texttt{double} function from Figure X.


% Alternatives and their trade-offs
% How better is the situation after implementing the new approach? MEASURE!
% Prevent bias

\section{Interaction between strategy and unification}
\label{sec:interaction-norm-strat}

Interestingly, only Ask-Elle combines model tracing with program transformations \cite{2016feedbackreview}

Aggressive unification helps checking programs when they are complete, but offers little help when checking programs that are incomplete.

For instance, imagine we add a normalization to identify reimplementations of map and transform them into a proper call to the map function.

After adding this transformation as a normalization step, it still does not help a student writing an incomplete program, because the normalization only makes sense in the context of a finished program. In fact, we can only now the student has reimplemented map after we see the finished program.

Therefore, normalization needs to strike the right balance between being overly aggressive and being too mild.

On the other hand, transforming wheres into lets is perfectly reasonable, as it doesn't have any influence in the...

\begin{figure}
\begin{minted}{haskell}
-- Recursive reimplementation of map
double [] = []
double (x:xs) = x * 2 : double xs

-- After transformation
double = map (* 2)
\end{minted}
\caption{An agressive normalization step}
\end{figure}

\begin{figure}
\begin{minted}{haskell}
-- Recursive reimplementation of map?
double [] = []
double (x:xs) = x * 2 : double ?
\end{minted}
\caption{Agressive normalization is ineffective on incomplete programs}
\end{figure}


\chapter{Background knowledge}

% What is wrong with the current approach Ask-Elle is taking?

Ask-Elle is a complex beast

...

\section{Program unification}

In order to provide hints and check the correctness of student answers, Ask-Elle relies on program unification. That is, a mechanism to compare two programs and determine whether:

\begin{enumerate}
    \item They are equal;
    \item One is an incomplete version of the other;
    \item Nothing can be concluded. % Note: true program unification would say that the programs are different, but we cannot say that since the problem is undecidable
\end{enumerate}

By using this technique, student answers can be compared to model solutions. In case a student answer turns out to be equal to the model solution, we know that the answer is correct. If it turns out to be an incomplete version of the model solution, we know that the student is on the right track and can offer them hints. If nothing can be concluded, Ask-Elle cannot offer any hints, but it will perform property-based testing so the student gets feedback regarding correctness.

At the core of program unification is the idea of normalization. Before comparing the programs, they go through a series of semantics-preserving transformations that result in a normal form. This way, comparing the programs becomes as simple as comparing the resulting normal forms for equality on their abstract syntax trees. It is also possible to check whether a program is a refinement of the other.

As an example, consider the function \mintinline{haskell}{double :: [Int] -> [Int]}, which doubles each element in a list of integers. The model solution, student answer and normalized version are shown below.

\begin{minted}{haskell}
-- Model solution
double = map (* 2)

-- Student answer
double = map (\x -> 2 * x)

-- Normalized version (similar for both)
double = map ((*) 2)
\end{minted}

\section{Limitations}

\subsection{Style-unaware program matching}

Ask-Elle's normalization procedure is designed to handle only small syntactical differences. Two programs can only be transformed to the same normal form if they follow the same style. As we saw above, this causes problems when attempting to provide hints for a program that diverges too much from its model solution. Let us consider again the \texttt{double} function, this time implemented in a recursive way:

\begin{minted}{haskell}
-- Original program
double [] = []
double (x:xs) = (x * 2) : double xs

-- Normalized
double = \y1 -> case y1 of
    [] -> []
    (x1 : x2) -> (:) ((*) x1 2) (double x2)
\end{minted}

It takes little time to see that this is basically a specialized reimplementation of map. Therefore it would be interesting to see it normalized as such:

\begin{minted}{haskell}
-- Desired normalization
double = map ((*) 2)
\end{minted}

Considering that reimplementing map is a common anti-pattern among beginners, it is unfortunate that they cannot get any hints in the presence of this style issue. In this regard, the lack of style-aware transformations has a clear impact on the user experience.

\section{Proposed solution}

On the long term, it seems worthwhile to enhance Ask-Elle with style-aware feedback and normalizations. Both features are closely related, as they both need to recognize the presence of style anti-patterns: the former, to report them; the latter, to normalize them. From the two, we think that normalization has a higher priority, since it enables giving hints in situations that were previously unsupported. We also expect most of the work on normalization to be reused when implementing style-aware feedback.

In light of the previous considerations, we propose to:

\begin{enumerate}
    \item Identify the main style issues that prevent Ask-Elle from matching semantically equivalent programs;
    \item Add new transformations to improve normalization of programs that present those issues;
    \item Assess the improvements in program matching derived from the new transformations.
\end{enumerate}
